---
title: "Synergy and Response analysis"
date: "`r Sys.Date()`"
output: html_document
params:
   dir_in: "../input/patient_data" # Input directory
   input_tsv: "supplementary_data.aza_ven.tsv" # Input TSV file
   dir_out: "../output/patient_data" # Output directory
   out_name: "aza_ven_18" # Output label
   col_target: "y" # Target column name in input file
   model_dual: NULL # Stan model for single-drug part in ../stan/
   model_bayesyc: "bayesyc-i_nb" # Stan model for combination part in ../stan/
   use_zeros: FALSE # Not to include zero-dose values in combination part
   #use_zeros: TRUE # To include zero-dose values using small positive values
   lb_log10_C: -10 # Lower bound of prior of log10(C)
   ub_log10_C: 6 # Upper bound of prior of log10(C)
   n_chains: 4 # Number of chains in MCMC sampling
   n_cores: 4 # Number of cores used per chain in MCMC sampling
   n_iter: 4000 # Number of iterations for both warmup and sampling phases in MCMC
   n_retry: 2 # Number of retry attempts for MCMC sampling if it fails
   l_pred: 20 # Number of data points for prediction
   thre_tc: 50 # Minimum T/C % to check
   thre_rhat: 1.1 # All Rhat values are required to be lower than this value for successful fit
   cmdstanr_tmp: NULL  # Directory for intermediate CSV files used by CmdStanR
   save_rds: FALSE
---


```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = FALSE)

library(ggplot2)
library(plotly)
library(dplyr)

dir.create(params$dir_out, showWarnings=F, recursive=F, mode="0750")
if(!is.null(params$cmdstanr_tmp)) dir.create(params$cmdstanr_tmp, showWarnings=F, recursive=F, mode="0750")

```

## Load data
Reads the input TSV into a data frame and constructs a Manual_Input_Double object to standardize and validate the input for downstream analysis.

```{r load_data}

# Read input TSV
df_input <- read.csv(file.path(params$dir_in, params$input_tsv), sep="\t", header=T, check.names=F, stringsAsFactors=F)

# Print parameters
out_params_ <- paste0(params$dir_out, "/params.",params$out_name,".tsv")
sink(out_params_)
for(p in names(params)){
  cat(p,"\t",params[[p]],"\n",sep="")
}
sink()

# Create whole input object
if(is.null(params$base_value)){
  whole_input <- bayesyc::Manual_Input_Double$new(params, df_input)
}else{
  df_input_excl_0 <- df_sim %>% dplyr::filter(conc_1 != 0 & conc_2 != 0)
  whole_input <- bayesyc::Manual_Input_Double$new(params, df_input_excl_0, base_value=params$base_value)
}

# Show input files' info
df_files <- data.frame(No=seq(whole_input$ls_data), Analysis=whole_input$v_analysis, Specimen=whole_input$v_specimen)
knitr::kable(df_files)

whole_input$process_input_data("target", params)

# Check stan model for dual single response
use_dual <- FALSE
if(!is.null(params$model_dual)){
  if(params$model_dual != "NULL"){
    use_dual <- TRUE
  }
}

# Check multi-metric or single-metric
multimetric <- TRUE
if(!is.null(params$col_target)){
  if(params$col_target != "NULL"){
    multimetric <- FALSE
  }
}

```

## Stats of controls
Computes summary statistics (mean, median, SD) for high and low control wells across datasets and prepares formatted tables for display. Assembles per-metric control summaries used for quality control checks.

```{r stats_control, warning=FALSE}

multimetric <- FALSE

#------------------------------
# Stats of controls

ls_data <- whole_input$ls_data
ls_show_hc <- NULL
ls_show_lc <- NULL
ls_show_v <- NULL
for(p in seq(ls_data)){

  ls_data[[p]]$set_summary_data()
  analysis <- ls_data[[p]]$analysis
  v_metric <- ls_data[[p]]$v_metric
  n_metric <- length(v_metric)
  # List to show HC
  ls_show_hc$V1 <- c(ls_show_hc$V1, rep(bayesyc::cat_file_info(p, analysis), n_metric))
  if(multimetric) ls_show_hc$V3 <- c(ls_show_hc$V3, v_metric)
  ls_show_hc$V4 <- c(ls_show_hc$V4, round(ls_data[[p]]$v_hc_mean, digits=1))
  ls_show_hc$V5 <- c(ls_show_hc$V5, round(ls_data[[p]]$v_hc_med, digits=1))
  ls_show_hc$V6 <- c(ls_show_hc$V6, round(ls_data[[p]]$v_hc_sd, digits=1))
  # List to show LC
  ls_show_lc$V1 <- c(ls_show_lc$V1, rep(bayesyc::cat_file_info(p, analysis), n_metric))
  if(multimetric) ls_show_lc$V3 <- c(ls_show_lc$V3, v_metric)
  ls_show_lc$V4 <- c(ls_show_lc$V4, round(ls_data[[p]]$v_lc_mean, digits=1))
  ls_show_lc$V5 <- c(ls_show_lc$V5, round(ls_data[[p]]$v_lc_med, digits=1))
  ls_show_lc$V6 <- c(ls_show_lc$V6, round(ls_data[[p]]$v_lc_sd, digits=1))
}

if(multimetric){
  multimetric_label <- 'Metric'
}else{
  multimetric_label <- NULL
}

knitr::kable(as.data.frame(ls_show_hc, col.names=c('High controls', multimetric_label, 'Mean', 'Median', 'SD'), check.names=F), row.names=F)
knitr::kable(as.data.frame(ls_show_lc, col.names=c('Low controls', multimetric_label, 'Mean', 'Median', 'SD'), check.names=F), row.names=F)

```

## Run MCMC sampling (CmdStan)
Compiles the specified Stan models (dual and BayeSyC) with CmdStanR and runs MCMC sampling via the Whole_Output_BayeSyC workflow.

```{r main, warning=FALSE, message=FALSE, results='hide'}

#------------------------------
# CmdStanR
if(use_dual){
  stan_model_dual <- cmdstanr::cmdstan_model(paste0("../stan/",params$model_dual,".stan"))
}else{
  stan_model_dual <- NULL
}
stan_model_bayesyc <- cmdstanr::cmdstan_model(paste0("../stan/",params$model_bayesyc,".stan"))

# Perform curve fitting by CmdStan sampling and resultant data processing
whole_output <- bayesyc::Whole_Output_BayeSyC$new(whole_input, stan_model_dual, stan_model_bayesyc, params)
# Save output RDS
if(params$save_rds) saveRDS(whole_output, file=paste0(params$dir_out,"/whole_output.",params$out_name,".rds"))

```

## Output summary statistics of results

```{r out_stats, warning=FALSE, class.output="bg-danger", size="Large"}

# Output stats in CSV format
out_stats_bayesyc_ <- paste0(params$dir_out,"/stats.",params$out_name,".csv")
write.table(whole_output$df_stats_bayesyc, file=out_stats_bayesyc_, sep=",", row.names=F, col.names=T, quote=F)

```

## Check fitting status
Iterates over datasets and metrics to detect and report failed model fits. 

```{r failed_fit_bayesyc, warning=FALSE, class.output="bg-danger", size="Large"}

#------------------------------
# Show message if the fitting fails

n_fit <- 0
for(p in seq(ls_data)){
  for(metric in ls_data[[p]]$v_metric){
    fit_bayesyc <- whole_output$ls_fit_bayesyc[[p]][[metric]]$fit_bayesyc
    if(is.null(fit_bayesyc$fit)){
      cat(ls_data[[p]]$analysis, paste0(": Fitting failed.\n"))
    }else{
      n_fit <- n_fit + 1
      if(!fit_bayesyc$success_fit) cat(ls_data[[p]]$analysis, ifelse(multimetric, metric, ""), paste0(": Fitting failed (does not satisfy the criteria).\n"))
      if(!fit_bayesyc$ok_Rhat) cat(ls_data[[p]]$analysis, ifelse(multimetric, metric, ""), paste0("does not satisfy Rhat < ", params$thre_rhat, "\n"))
    }
  }
}

```

## Draw dose response surface
Builds interactive 3D scatter and surface plots (plotly) showing predicted dose–response surfaces (2.5%, 50%, 97.5% intervals) for each dataset and metric.

```{r plotly_surface}

tL <- htmltools::tagList()

#------------------------------
# 3D surface plot
for(p in seq(whole_output$ls_res_bayesyc)){

  # Show input file info
  tL[[length(tL) + 1]] <- formattable::as.htmlwidget(formattable::formattable(df_files[p, ], align="l", row.names=F))
  
  for(metric in ls_data[[p]]$v_metric){
    
    predictions <- whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc$predictions
    df_x_matrix <- whole_output$ls_res_bayesyc[[p]][[metric]]$df_x_matrix
    ls_in <- whole_output$ls_fit_bayesyc[[p]][[metric]]$fit_bayesyc$input
  
    comp1 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[1]
    comp2 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[2]
  
    # Data option buttons
    data_types <- list(type= 'buttons',
      buttons = list(
        list(label = "None", method = "update",
             args = list(list(visible = c(TRUE, FALSE, FALSE, FALSE)))),
        list(label = "2.5%", method = "update",
             args = list(list(visible = c(TRUE, TRUE, FALSE, FALSE)))),
        list(label = "50%", method = "update",
             args = list(list(visible = c(TRUE, FALSE, TRUE, FALSE)))),
        list(label = "97.5%", method = "update",
             args = list(list(visible = c(TRUE, FALSE, FALSE, TRUE)))),
        list(label = "2.5% - 97.5%", method = "update",
             args = list(list(visible = c(TRUE, TRUE, FALSE, TRUE))))
      )
    )
  
    # Plotly object
    fig <- plot_ly(data=df_x_matrix, height=400, width=700)
    fig <- fig %>% add_trace(x=df_x_matrix$conc_1, y=df_x_matrix$conc_2, z=df_x_matrix$y, mode="markers", type="scatter3d",  marker=list(size=1.5, color="black", alpha=0.5, symbol=104))
    if(whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc$success_fit){
      fig <- fig %>% add_surface(name="2.5%", z=predictions$mx_surface_lower, x=ls_in$v_x1_new, y=ls_in$v_x2_new, type="surface", colorscale="Jet", alpha=0.5)
      fig <- fig %>% add_surface(name="50%", z=predictions$mx_surface_median, x=ls_in$v_x1_new, y=ls_in$v_x2_new, type="surface", colorscale="Jet", alpha=0.5)
      fig <- fig %>% add_surface(name="97.5%", z=predictions$mx_surface_upper, x=ls_in$v_x1_new, y=ls_in$v_x2_new, type="surface", colorscale="Jet", alpha=0.5)
    }
    fig <- fig %>% layout(
      updatemenus = list(data_types),
      title = ifelse(multimetric, metric, ""),
      scene = list( xaxis = list(title=paste(comp1), type="log", exponentformat="none"),
                    yaxis = list(title=paste(comp2), type="log", exponentformat="none"),
                    zaxis = list(title=metric, tickformat=',') ))
  
    # Show figure
    tL[[length(tL) + 1]] <- as_widget(fig)
  }
}
tL

```

## Draw dose response heatmap
### Treatment vs Control (%) in median
Creates interactive median treatment-vs-control (%) visualizations as heatmaps, contours, or 3D surfaces with plotly, including chart-type buttons and layout settings.

```{r plotly_heatmap}

tL <- htmltools::tagList()

#------------------------------
# Heatmap, contour and 3D surface plot
for(p in seq(whole_output$ls_res_bayesyc)){

  # Show input file info
  tL[[length(tL) + 1]] <- formattable::as.htmlwidget(formattable::formattable(df_files[p, ], align="l", row.names=F))
  plate <- whole_output$ls_data[[p]]$plate

  for(metric in ls_data[[p]]$v_metric){
    if(!whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc$success_fit) next
  
    predictions <- whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc$predictions
    df_x_matrix <- whole_output$ls_res_bayesyc[[p]][[metric]]$df_x_matrix
    ls_in <- whole_output$ls_fit_bayesyc[[p]][[metric]]$fit_bayesyc$input
  
    comp1 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[1]
    comp2 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[2]
  
    # Chart option buttons
    chart_types <- list(type = "buttons",
      buttons = list(
        list(method = "restyle", args = list("type", "heatmap"), label = "Heatmap"),
        list(method = "restyle", args = list("type", "contour"), label = "Contour"),
        list(method = "restyle", args = list("type", "surface"), label = "Surface")
      )
    )
  
    # Plotly object
    fig <- plot_ly(z=predictions$mx_surface_median_tc, x=ls_in$v_x1_new, y=ls_in$v_x2_new,
                   type="contour", height=400, width=700, colorscale="Jet")
    fig <- fig %>% layout(
      xaxis = list(title = paste(comp1), domain=c(0.3, 1), type="log", exponentformat="none"),
      yaxis = list(title = paste(comp2), domain=c(0.1, 1), type="log", exponentformat="none"),
      updatemenus = list(chart_types),
      title = ifelse(multimetric, metric, ""),
      scene = list( xaxis = list(title=paste(comp1), type="log", exponentformat="none"),
                    yaxis = list(title=paste(comp2), type="log", exponentformat="none"),
                    zaxis = list(title=paste("T/C [%]")) ))
  
    # Show figure
    tL[[length(tL) + 1]] <- as_widget(fig)
  }
}
tL

```

## Show estimated BayeSyC parameters
Extracts parameter summaries from successful fits and renders a series of interactive plots (alpha, potency C, beta, effect E, cooperativity h) to visualize estimates with uncertainty. 

```{r plot_bayesyc_params, results='asis'}

#------------------------------
# Plot estimated BayeSyC parameters
for(p in seq(whole_output$ls_res_bayesyc)){

  # Show input file info
  print(knitr::kable(df_files[p, ], row.names=F))
  plate <- whole_output$ls_data[[p]]$plate
  
  for(metric in ls_data[[p]]$v_metric){
    if(!whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc$success_fit) next
    
    tL <- htmltools::tagList()
    
    df_x_matrix <- whole_output$ls_res_bayesyc[[p]][[metric]]$df_x_matrix
    fit_bayesyc <- whole_output$ls_res_bayesyc[[p]][[metric]]$fit_bayesyc
    estimates <- fit_bayesyc$estimates
  
    comp1 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[1]
    comp2 <- whole_output$ls_res_bayesyc[[p]][[metric]]$comp[2]
    
    if(multimetric){
      tL <- htmltools::tagAppendChild(tL, htmltools::tagList(htmltools::h3(metric, style = "text-align: left;"))) 
    }
    
    #------------------------------ 
    # Synergistic potency (Alpha)
    df_estimate_a <- estimates$df[c("alpha12", "alpha21"), ]
    g1 <- ggplot(df_estimate_a, aes(x=parameter, y=`50%`, `2.5%`=`2.5%`, `97.5%`=`97.5%`))
    g1 <- g1 + theme_bw()
    g1 <- g1 + geom_point(alpha=0.7, show.legend=F)
    g1 <- g1 + geom_errorbar(aes(ymin=`2.5%`, ymax=`97.5%`), width=0)
    g1 <- g1 + ggtitle("Synergistic potency (synergy to IC50)") + ylab("Antagonistic <–––––> Synergistic&nbsp;") + xlab("Parameter")
    g1 <- g1 + scale_x_discrete(limits = rev, 
                                labels=c(paste0("Influence of\n",comp2," to\n",comp1,"'s potency","\n(α21)"),
                                         paste0("Influence of\n",comp1," to\n",comp2,"'s potency","\n(α12)")))
    g1 <- g1 + scale_y_log10(breaks=c(0.001, 0.01, 0.1, 1, 10, 100, 1000), labels=c("0.001", "0.01", "0.1", "1", "10", "100", "1000"))
    g1 <- g1 + coord_flip(ylim=c(0.001, 1000))
    pg1 <- ggplotly(g1, height=300, width=750)
    tL <- htmltools::tagAppendChild(tL, as_widget(pg1))
    
    #------------------------------ 
    # Potency (IC50)
    v_all_conc <- c(df_x_matrix$conc_1, df_x_matrix$conc_2)
    c_min <- min(v_all_conc[v_all_conc > 0]) / 5
    c_max <- max(v_all_conc[v_all_conc > 0]) * 5
    df_estimate_C <- estimates$df[c("C1", "C2"), ]
    g2 <- ggplot(df_estimate_C, aes(x=parameter, y=`50%`, `2.5%`=`2.5%`, `97.5%`=`97.5%`))
    g2 <- g2 + theme_bw()
    g2 <- g2 + geom_point(alpha=0.7, show.legend=F)
    g2 <- g2 + geom_errorbar(aes(ymin=`2.5%`, ymax=`97.5%`), width=0)
    g2 <- g2 + ggtitle("Potency (IC50)") + ylab("Estimated potency (IC50)") + xlab("Compound")
    g2 <- g2 + scale_x_discrete(limits = rev, labels=c(paste0(comp2," (C2)"), paste0(comp1," (C1)")))
    g2 <- g2 + scale_y_log10(labels = scales::label_number())
    g2 <- g2 + coord_flip(ylim=c(c_min, c_max))
    pg2 <- ggplotly(g2, height=300, width=750)
    tL <- htmltools::tagAppendChild(tL, as_widget(pg2))
  
    #------------------------------ 
    # Synergistic efficacy (Beta)
    df_estimate_beta <- estimates$df["beta", ]
    b_max <- max(abs(c(df_estimate_beta$`2.5%`, df_estimate_beta$`97.5%`, 1)))
    g3 <- ggplot(df_estimate_beta, aes(x=parameter, y=`50%`, `2.5%`=`2.5%`, `97.5%`=`97.5%`))
    g3 <- g3 + theme_bw()
    g3 <- g3 + geom_point(alpha=0.7, show.legend=F)
    g3 <- g3 + geom_errorbar(aes(ymin=`2.5%`, ymax=`97.5%`), width=0)
    g3 <- g3 + ggtitle("Synergistic efficacy (synergy to maximal effect)") + ylab("Antagonistic <–––––> Synergistic&nbsp;") + xlab("Parameter")
    g3 <- g3 + scale_x_discrete(limits = rev, labels=c(paste0("Influence of\nthe combination to\nmaximal effect\n(β)")))
    g3 <- g3 + scale_y_continuous(labels = scales::label_number())
    g3 <- g3 + coord_flip(ylim=c(- b_max, b_max))
    pg3 <- ggplotly(g3, height=250, width=750)
    tL <- htmltools::tagAppendChild(tL, as_widget(pg3))
  
    #------------------------------ 
    # Effect
    df_estimate_E <- estimates$df[c("E1", "E2", "E3"), ]
    df_estimate_E[, c("2.5%", "50%", "97.5%")] <- df_estimate_E[, c("2.5%", "50%", "97.5%")] * fit_bayesyc$sf_tc # T/C
    g4 <- ggplot(df_estimate_E, aes(x=parameter, y=`50%`, `2.5%`=`2.5%`, `97.5%`=`97.5%`))
    g4 <- g4 + theme_bw()
    g4 <- g4 + geom_point(alpha=0.7, show.legend=F)
    g4 <- g4 + geom_errorbar(aes(ymin=`2.5%`, ymax=`97.5%`), width=0)
    g4 <- g4 + ggtitle("Effect") + ylab("Estimated effect (T/C) [%]") + xlab("Compound")
    g4 <- g4 + scale_x_discrete(limits = rev, labels=c(paste0("Combination (E3)"), paste0(comp2," (E2)"), paste0(comp1," (E1)")))
    g4 <- g4 + coord_flip(ylim=c(0, 100))
    pg4 <- ggplotly(g4, height=350, width=750)
    tL <- htmltools::tagAppendChild(tL, as_widget(pg4))
  
    #------------------------------ 
    # Cooperativity (Hill coeﬃcient)
    df_estimate_h <- estimates$df[c("h1", "h2"), ]
    h_max <- max(abs(c(df_estimate_h$`2.5%`, df_estimate_h$`97.5%`, 5)))
    g5 <- ggplot(df_estimate_h, aes(x=parameter, y=`50%`, `2.5%`=`2.5%`, `97.5%`=`97.5%`))
    g5 <- g5 + theme_bw()
    g5 <- g5 + geom_point(alpha=0.7, show.legend=F)
    g5 <- g5 + geom_errorbar(aes(ymin=`2.5%`, ymax=`97.5%`), width=0)
    g5 <- g5 + ggtitle("Cooperativity (Hill coeﬃcient)") + ylab("Estimated cooperativity") + xlab("Compound")
    g5 <- g5 + scale_x_discrete(limits = rev, labels=c(paste0(comp2," (h2)"), paste0(comp1," (h1)")))
    g5 <- g5 + scale_y_continuous(labels = scales::label_number())
    g5 <- g5 + coord_flip(ylim=c(0, h_max))
    pg5 <- ggplotly(g5, height=300, width=750)
    tL <- htmltools::tagAppendChild(tL, as_widget(pg5))
  
    print(tL)
  }
}

```
